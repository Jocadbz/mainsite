<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Why you should be programming in V (And why you shouldn't) - jocadbz</title>
    <link rel="icon" type="image/x-icon" href="../lain.ico">
    <link rel="stylesheet" href="../styles.css">
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 0 20px;
            text-align: justify;
        }
        p {
            margin-bottom: 20px;
        }
        img {
            display: block;
            margin: 0 auto;
        }
        .image-description {
            text-align: center;
            margin-left: auto;
            margin-right: auto;
            margin-top: 10px;
            font-style: italic;
            margin-bottom: 20px;
        }
        @media (max-width: 600px) {
            body {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Why you should be programming in V (And why you shouldn't)</h1>
    <div class="links" style="text-align: center;">
        <a href="../index.html">home</a>
        <a href="blog.html">blog</a>
    </div>
    <h2 style="text-align: center;">13/08/25</h2>
    <p>
I think it's no surprise to anybody close to me that my favorite programming language is currently <a href="https://vlang.io">V</a>. It has been my go-to language for scripts, apps, GUI programs and anything in between. But it is still a well-unknown language, mainly because it is very new (first released circa 2019) and some of its features are not yet stable (More on that below.)
    </p>

    <h2 style="text-align: center;">Why I like it, benefits and more</h2>
    <p>
I'm assuming most of you are programmers. So I will take the liberty of diving into more technical aspects of V's architecture.
    </p>

    <h3 style="text-align: center;">Simple and Clean Syntax</h3>
    <p>
V's syntax is especially easy to read and write. This is particularly beneficial in a language where you are able to dive into low-level programming. That's mainly because it imitates a lot of what Python and Go do in terms of syntax, and prevents the kind of complexity seen in languages like Rust and Java (Sorry Rustaceans.)
<pre><code>
// This is a simple V app from their example section.
// Print file lines that start with "DEBUG:"
import os

// `read_file` returns an optional (`?string`), it must be checked
text := os.read_file('app.log') or {
    // `err` is a special variable that contains the error
    // in `or {}` blocks
    eprintln('failed to read the file: ${err}')
    return
}

lines := text.split_into_lines()
for line in lines {
    if line.starts_with('DEBUG:') {
        println(line)
    }
}
</pre></code>
    </p>

    <h3 style="text-align: center;">Safety</h3>
    <p>
V prioritizes safety with features that prevent common programming errors. This includes immutability by default, which means variables and structs can't be changed after they're created unless explicitly marked as mutable. It also has mandatory error checking and no null pointers, helping to eliminate a whole class of bugs. That comes as a surprise in this regard, especially since V uses C as a backend.
    </p>

    <h3 style="text-align: center;">Memory Management</h3>
    <p>
V offers a variety of memory management options.
    </p>
    <ul>
      <li>Optional garbage collection (GC)</li>
      <li>Manual memory management by disabling the GC (-gc none)</li>
      <li>Autofree, which handles most objects via intelligent free call insertion, with the remaining percentage optionally freed by GC (-autofree).</li>
      <li>Arena allocation (-prealloc).</li>
    </ul>
    <p>
This is a hot take, but in most cases, you don't need a complex memory management strategy. If your app is designed to run occasionally and not stay open for too long, not using GC actually speeds it up a lot. Then, after using it, the kernel takes care of reclaiming the rest of the memory. If not, you may use the options above or handle it manually like a champ.
    </p>

    <h3 style="text-align: center;">Excellent C Interoperability</h3>
    <p>
V has seamless interoperability with C. This means you can directly use existing C libraries without any FFI overhead, much like Rust does.
    </p>

    <h2 style="text-align: center;">Why you shouldn't be programming in V (Or should be cautious)</h2>
    <p>
No language is perfect, and V, despite its many advantages, has its share of caveats. It is not yet 100% stable (I have ran into some problems before. They usually happens when you try to mess with stuff that makes C think your code is valid, but it panics on runtime.). Also, V does not have some libraries you might want. Even though you can call them for C, if you find a library that is missing on V, and you don't want to code a wrapper for it, it's best to go to another language for now.
    </p>
    <h2 style="text-align: center;">should you code in V?</h2>
    <p>
TLDR: Yes.

V is amazing. Apart for some stuff that might go wrong if you mess with stuff you shouldn't, it's fast, stable, compatible and very easy to code and to maintain. Right now, I am coding a feature complete package manager on it, and the experience is amazing. Updates on that soon.

Thanks for reading.
    </p>
</body>
</html>
